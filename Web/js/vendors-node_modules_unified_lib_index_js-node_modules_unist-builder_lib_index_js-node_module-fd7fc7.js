"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkvadmin_front"] = self["webpackChunkvadmin_front"] || []).push([["vendors-node_modules_unified_lib_index_js-node_modules_unist-builder_lib_index_js-node_module-fd7fc7"],{

/***/ "./node_modules/trough/index.js":
/*!**************************************!*\
  !*** ./node_modules/trough/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"trough\": function() { return /* binding */ trough; },\n/* harmony export */   \"wrap\": function() { return /* binding */ wrap; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n\n\n\n/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */\nfunction trough() {\n  /** @type {Array<Middleware>} */\n  const fns = [];\n  /** @type {Pipeline} */\n\n  const pipeline = {\n    run,\n    use\n  };\n  return pipeline;\n  /** @type {Run} */\n\n  function run(...values) {\n    let middlewareIndex = -1;\n    /** @type {Callback} */\n\n    const callback = values.pop();\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback);\n    }\n\n    next(null, ...values);\n    /**\n     * Run the next `fn`, or weâ€™re done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */\n\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex];\n      let index = -1;\n\n      if (error) {\n        callback(error);\n        return;\n      } // Copy non-nullish input into values.\n\n\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index];\n        }\n      } // Save the newly created `output` for the next call.\n\n\n      values = output; // Next or done.\n\n      if (fn) {\n        wrap(fn, next)(...output);\n      } else {\n        callback(null, ...output);\n      }\n    }\n  }\n  /** @type {Use} */\n\n\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError('Expected `middelware` to be a function, not ' + middelware);\n    }\n\n    fns.push(middelware);\n    return pipeline;\n  }\n}\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */\n\nfunction wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called;\n  return wrapped;\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length;\n    /** @type {any} */\n\n    let result;\n\n    if (fnExpectsCallback) {\n      parameters.push(done);\n    }\n\n    try {\n      result = middleware.apply(this, parameters);\n    } catch (error) {\n      const exception =\n      /** @type {Error} */\n      error; // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n\n      if (fnExpectsCallback && called) {\n        throw exception;\n      }\n\n      return done(exception);\n    }\n\n    if (!fnExpectsCallback) {\n      if (result instanceof Promise) {\n        result.then(then, done);\n      } else if (result instanceof Error) {\n        done(result);\n      } else {\n        then(result);\n      }\n    }\n  }\n  /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */\n\n\n  function done(error, ...output) {\n    if (!called) {\n      called = true;\n      callback(error, ...output);\n    }\n  }\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n\n\n  function then(value) {\n    done(null, value);\n  }\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/trough/index.js?");

/***/ }),

/***/ "./node_modules/unified/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/unified/lib/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unified\": function() { return /* binding */ unified; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var bail__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bail */ \"./node_modules/bail/index.js\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\");\n/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\");\n/* harmony import */ var is_plain_obj__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! is-plain-obj */ \"./node_modules/unified/node_modules/is-plain-obj/index.js\");\n/* harmony import */ var trough__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! trough */ \"./node_modules/trough/index.js\");\n/* harmony import */ var vfile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vfile */ \"./node_modules/vfile/lib/index.js\");\n\n\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\n\n\n\n\n // Expose a frozen processor.\n\nconst unified = base().freeze();\nconst own = {}.hasOwnProperty; // Function to create the first processor.\n\n/**\n * @returns {Processor}\n */\n\nfunction base() {\n  const transformers = (0,trough__WEBPACK_IMPORTED_MODULE_5__.trough)();\n  /** @type {Processor['attachers']} */\n\n  const attachers = [];\n  /** @type {Record<string, unknown>} */\n\n  let namespace = {};\n  /** @type {boolean|undefined} */\n\n  let frozen;\n  let freezeIndex = -1; // Data management.\n  // @ts-expect-error: overloads are handled.\n\n  processor.data = data;\n  processor.Parser = undefined;\n  processor.Compiler = undefined; // Lock.\n\n  processor.freeze = freeze; // Plugins.\n\n  processor.attachers = attachers; // @ts-expect-error: overloads are handled.\n\n  processor.use = use; // API.\n\n  processor.parse = parse;\n  processor.stringify = stringify; // @ts-expect-error: overloads are handled.\n\n  processor.run = run;\n  processor.runSync = runSync; // @ts-expect-error: overloads are handled.\n\n  processor.process = process;\n  processor.processSync = processSync; // Expose.\n\n  return processor; // Create a new processor based on the processor in the current scope.\n\n  /** @type {Processor} */\n\n  function processor() {\n    const destination = base();\n    let index = -1;\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index]);\n    }\n\n    destination.data(extend__WEBPACK_IMPORTED_MODULE_3__(true, {}, namespace));\n    return destination;\n  }\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n\n\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen);\n        namespace[key] = value;\n        return processor;\n      } // Get `key`.\n\n\n      return own.call(namespace, key) && namespace[key] || null;\n    } // Set space.\n\n\n    if (key) {\n      assertUnfrozen('data', frozen);\n      namespace = key;\n      return processor;\n    } // Get space.\n\n\n    return namespace;\n  }\n  /** @type {Processor['freeze']} */\n\n\n  function freeze() {\n    if (frozen) {\n      return processor;\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex];\n\n      if (options[0] === false) {\n        continue;\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined;\n      }\n      /** @type {Transformer|void} */\n\n\n      const transformer = attacher.call(processor, ...options);\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer);\n      }\n    }\n\n    frozen = true;\n    freezeIndex = Number.POSITIVE_INFINITY;\n    return processor;\n  }\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n\n\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings;\n    assertUnfrozen('use', frozen);\n\n    if (value === null || value === undefined) {// Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options);\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value);\n      } else {\n        addPreset(value);\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`');\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings);\n    }\n\n    return processor;\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value);\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value;\n          addPlugin(plugin, ...options);\n        } else {\n          addPreset(value);\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`');\n      }\n    }\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n\n\n    function addPreset(result) {\n      addList(result.plugins);\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings);\n      }\n    }\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n\n\n    function addList(plugins) {\n      let index = -1;\n\n      if (plugins === null || plugins === undefined) {// Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index];\n          add(thing);\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`');\n      }\n    }\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n\n\n    function addPlugin(plugin, value) {\n      let index = -1;\n      /** @type {Processor['attachers'][number]|undefined} */\n\n      let entry;\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index];\n          break;\n        }\n      }\n\n      if (entry) {\n        if ((0,is_plain_obj__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(entry[1]) && (0,is_plain_obj__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(value)) {\n          value = extend__WEBPACK_IMPORTED_MODULE_3__(true, entry[1], value);\n        }\n\n        entry[1] = value;\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments]);\n      }\n    }\n  }\n  /** @type {Processor['parse']} */\n\n\n  function parse(doc) {\n    processor.freeze();\n    const file = vfile(doc);\n    const Parser = processor.Parser;\n    assertParser('parse', Parser);\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse();\n    } // @ts-expect-error: `newable` checks this.\n\n\n    return Parser(String(file), file); // eslint-disable-line new-cap\n  }\n  /** @type {Processor['stringify']} */\n\n\n  function stringify(node, doc) {\n    processor.freeze();\n    const file = vfile(doc);\n    const Compiler = processor.Compiler;\n    assertCompiler('stringify', Compiler);\n    assertNode(node);\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile();\n    } // @ts-expect-error: `newable` checks this.\n\n\n    return Compiler(node, file); // eslint-disable-line new-cap\n  }\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n\n\n  function run(node, doc, callback) {\n    assertNode(node);\n    processor.freeze();\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc;\n      doc = undefined;\n    }\n\n    if (!callback) {\n      return new Promise(executor);\n    }\n\n    executor(null, callback);\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` canâ€™t be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done);\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n\n      function done(error, tree, file) {\n        tree = tree || node;\n\n        if (error) {\n          reject(error);\n        } else if (resolve) {\n          resolve(tree);\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file);\n        }\n      }\n    }\n  }\n  /** @type {Processor['runSync']} */\n\n\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result;\n    /** @type {boolean|undefined} */\n\n    let complete;\n    processor.run(node, file, done);\n    assertDone('runSync', 'run', complete); // @ts-expect-error: we either bailed on an error or have a tree.\n\n    return result;\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n\n    function done(error, tree) {\n      (0,bail__WEBPACK_IMPORTED_MODULE_6__.bail)(error);\n      result = tree;\n      complete = true;\n    }\n  }\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n\n\n  function process(doc, callback) {\n    processor.freeze();\n    assertParser('process', processor.Parser);\n    assertCompiler('process', processor.Compiler);\n\n    if (!callback) {\n      return new Promise(executor);\n    }\n\n    executor(null, callback);\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n\n    function executor(resolve, reject) {\n      const file = vfile(doc);\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error);\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file);\n\n          if (result === undefined || result === null) {// Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result;\n          } else {\n            file.result = result;\n          }\n\n          done(error, file);\n        }\n      });\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n\n      function done(error, file) {\n        if (error || !file) {\n          reject(error);\n        } else if (resolve) {\n          resolve(file);\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file);\n        }\n      }\n    }\n  }\n  /** @type {Processor['processSync']} */\n\n\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete;\n    processor.freeze();\n    assertParser('processSync', processor.Parser);\n    assertCompiler('processSync', processor.Compiler);\n    const file = vfile(doc);\n    processor.process(file, done);\n    assertDone('processSync', 'process', complete);\n    return file;\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n\n    function done(error) {\n      complete = true;\n      (0,bail__WEBPACK_IMPORTED_MODULE_6__.bail)(error);\n    }\n  }\n}\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\n\n\nfunction newable(value, name) {\n  return typeof value === 'function' && // Prototypes do exist.\n  // type-coverage:ignore-next-line\n  value.prototype && ( // A function with keys in its prototype is probably a constructor.\n  // Classesâ€™ prototype methods are not enumerable, so we check if some value\n  // exists in the prototype.\n  // type-coverage:ignore-next-line\n  keys(value.prototype) || name in value.prototype);\n}\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\n\n\nfunction keys(value) {\n  /** @type {string} */\n  let key;\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\n\n\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`');\n  }\n}\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\n\n\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`');\n  }\n}\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\n\n\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error('Cannot call `' + name + '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.');\n  }\n}\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\n\n\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!(0,is_plain_obj__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`'); // Fine.\n  }\n}\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\n\n\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\n  }\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\n\n\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new vfile__WEBPACK_IMPORTED_MODULE_7__.VFile(value);\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\n\n\nfunction looksLikeAVFile(value) {\n  return Boolean(value && typeof value === 'object' && 'message' in value && 'messages' in value);\n}\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\n\n\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || is_buffer__WEBPACK_IMPORTED_MODULE_2__(value);\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/unified/lib/index.js?");

/***/ }),

/***/ "./node_modules/unified/node_modules/is-plain-obj/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/unified/node_modules/is-plain-obj/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ isPlainObject; }\n/* harmony export */ });\nfunction isPlainObject(value) {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/unified/node_modules/is-plain-obj/index.js?");

/***/ }),

/***/ "./node_modules/unist-builder/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/unist-builder/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"u\": function() { return /* binding */ u; }\n/* harmony export */ });\n/**\n * @typedef {import('unist').Node} Node\n */\n\n/**\n * @typedef {Array<Node> | string} ChildrenOrValue\n *   List to use as `children` or value to use as `value`.\n *\n * @typedef {Record<string, unknown>} Props\n *   Other fields to add to the node.\n */\n\n/**\n * Build a node.\n *\n * @param type\n *   Node type.\n * @param props\n *   Fields assigned to node.\n * @param value\n *   Children of node or value of `node` (cast to string).\n * @returns\n *   Built node.\n */\nconst u =\n/**\n * @type {(\n *   (<T extends string>(type: T) => {type: T}) &\n *   (<T extends string, P extends Props>(type: T, props: P) => {type: T} & P) &\n *   (<T extends string>(type: T, value: string) => {type: T, value: string}) &\n *   (<T extends string, P extends Props>(type: T, props: P, value: string) => {type: T, value: string} & P) &\n *   (<T extends string, C extends Array<Node>>(type: T, children: C) => {type: T, children: C}) &\n *   (<T extends string, P extends Props, C extends Array<Node>>(type: T, props: P, children: C) => {type: T, children: C} & P)\n * )}\n */\n\n/**\n * @param {string} type\n * @param {Props | ChildrenOrValue | null | undefined} [props]\n * @param {ChildrenOrValue | null | undefined} [value]\n * @returns {Node}\n */\nfunction (type, props, value) {\n  /** @type {Node} */\n  const node = {\n    type: String(type)\n  };\n\n  if ((value === undefined || value === null) && (typeof props === 'string' || Array.isArray(props))) {\n    value = props;\n  } else {\n    Object.assign(node, props);\n  }\n\n  if (Array.isArray(value)) {\n    // @ts-expect-error: create a parent.\n    node.children = value;\n  } else if (value !== undefined && value !== null) {\n    // @ts-expect-error: create a literal.\n    node.value = String(value);\n  }\n\n  return node;\n};\n\n//# sourceURL=webpack://vadmin-front/./node_modules/unist-builder/lib/index.js?");

/***/ }),

/***/ "./node_modules/unist-util-generated/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/unist-util-generated/lib/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generated\": function() { return /* binding */ generated; }\n/* harmony export */ });\n/**\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef NodeLike\n * @property {PositionLike | null | undefined} [position]\n */\n\n/**\n * Check if `node` is generated.\n *\n * @param {NodeLike | null | undefined} [node]\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is generated (does not have positional info).\n */\nfunction generated(node) {\n  return !node || !node.position || !node.position.start || !node.position.start.line || !node.position.start.column || !node.position.end || !node.position.end.line || !node.position.end.column;\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/unist-util-generated/lib/index.js?");

/***/ }),

/***/ "./node_modules/unist-util-is/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/unist-util-is/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convert\": function() { return /* binding */ convert; },\n/* harmony export */   \"is\": function() { return /* binding */ is; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The nodeâ€™s position in its parent.\n * @param parent\n *   The nodeâ€™s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nconst is =\n/**\n * @type {(\n *   (() => false) &\n *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n * )}\n */\n\n/**\n * @param {unknown} [node]\n * @param {Test} [test]\n * @param {number | null | undefined} [index]\n * @param {Parent | null | undefined} [parent]\n * @param {unknown} [context]\n * @returns {boolean}\n */\n// eslint-disable-next-line max-params\nfunction is(node, test, index, parent, context) {\n  const check = convert(test);\n\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite index');\n  }\n\n  if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) {\n    throw new Error('Expected parent node');\n  }\n\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n    throw new Error('Expected both parent and index');\n  } // @ts-expect-error Looks like a node.\n\n\n  return node && node.type && typeof node.type === 'string' ? Boolean(check.call(context, node, index, parent)) : false;\n};\n/**\n * Generate an assertion from a test.\n *\n * Useful if youâ€™re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\n\nconst convert =\n/**\n * @type {(\n *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n *   ((test?: Test) => AssertAnything)\n * )}\n */\n\n/**\n * @param {Test} [test]\n * @returns {AssertAnything}\n */\nfunction (test) {\n  if (test === undefined || test === null) {\n    return ok;\n  }\n\n  if (typeof test === 'string') {\n    return typeFactory(test);\n  }\n\n  if (typeof test === 'object') {\n    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);\n  }\n\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n\n  throw new Error('Expected function, string, or object as test');\n};\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\n\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = [];\n  let index = -1;\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index]);\n  }\n\n  return castFactory(any);\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function any(...parameters) {\n    let index = -1;\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true;\n    }\n\n    return false;\n  }\n}\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\n\n\nfunction propsFactory(check) {\n  return castFactory(all);\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n\n  function all(node) {\n    /** @type {string} */\n    let key;\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false;\n    }\n\n    return true;\n  }\n}\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\n\n\nfunction typeFactory(check) {\n  return castFactory(type);\n  /**\n   * @param {Node} node\n   */\n\n  function type(node) {\n    return node && node.type === check;\n  }\n}\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\n\n\nfunction castFactory(check) {\n  return assertion;\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function assertion(node, ...parameters) {\n    return Boolean(node && typeof node === 'object' && 'type' in node && // @ts-expect-error: fine.\n    Boolean(check.call(this, node, ...parameters)));\n  }\n}\n\nfunction ok() {\n  return true;\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/unist-util-is/lib/index.js?");

/***/ }),

/***/ "./node_modules/unist-util-position/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/unist-util-position/lib/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pointEnd\": function() { return /* binding */ pointEnd; },\n/* harmony export */   \"pointStart\": function() { return /* binding */ pointStart; },\n/* harmony export */   \"position\": function() { return /* binding */ position; }\n/* harmony export */ });\n/**\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nconst pointStart = point('start');\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\n\nconst pointEnd = point('end');\n/**\n * Get the positional info of `node`.\n *\n * @param {NodeLike | Node | null | undefined} [node]\n *   Node.\n * @returns {Position}\n *   Position.\n */\n\nfunction position(node) {\n  return {\n    start: pointStart(node),\n    end: pointEnd(node)\n  };\n}\n/**\n * Get the positional info of `node`.\n *\n * @param {'start' | 'end'} type\n *   Side.\n * @returns\n *   Getter.\n */\n\nfunction point(type) {\n  return point;\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {NodeLike | Node | null | undefined} [node]\n   * @returns {Point}\n   */\n\n  function point(node) {\n    const point = node && node.position && node.position[type] || {}; // To do: next major: donâ€™t return points when invalid.\n\n    return {\n      // @ts-expect-error: in practice, null is allowed.\n      line: point.line || null,\n      // @ts-expect-error: in practice, null is allowed.\n      column: point.column || null,\n      // @ts-expect-error: in practice, null is allowed.\n      offset: point.offset > -1 ? point.offset : null\n    };\n  }\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/unist-util-position/lib/index.js?");

/***/ }),

/***/ "./node_modules/unist-util-stringify-position/lib/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/unist-util-stringify-position/lib/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stringifyPosition\": function() { return /* binding */ stringifyPosition; }\n/* harmony export */ });\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nfunction stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return '';\n  } // Node.\n\n\n  if ('position' in value || 'type' in value) {\n    return position(value.position);\n  } // Position.\n\n\n  if ('start' in value || 'end' in value) {\n    return position(value);\n  } // Point.\n\n\n  if ('line' in value || 'column' in value) {\n    return point(value);\n  } // ?\n\n\n  return '';\n}\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\n\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column);\n}\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\n\n\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end);\n}\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\n\n\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1;\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/unist-util-stringify-position/lib/index.js?");

/***/ }),

/***/ "./node_modules/unist-util-visit-parents/lib/color.browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/unist-util-visit-parents/lib/color.browser.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"color\": function() { return /* binding */ color; }\n/* harmony export */ });\n/**\n * @param {string} d\n * @returns {string}\n */\nfunction color(d) {\n  return d;\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/unist-util-visit-parents/lib/color.browser.js?");

/***/ }),

/***/ "./node_modules/unist-util-visit-parents/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/unist-util-visit-parents/lib/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONTINUE\": function() { return /* binding */ CONTINUE; },\n/* harmony export */   \"EXIT\": function() { return /* binding */ EXIT; },\n/* harmony export */   \"SKIP\": function() { return /* binding */ SKIP; },\n/* harmony export */   \"visitParents\": function() { return /* binding */ visitParents; }\n/* harmony export */ });\n/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ \"./node_modules/unist-util-is/lib/index.js\");\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ \"./node_modules/unist-util-visit-parents/lib/color.browser.js\");\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\n\n/**\n * Continue traversing as normal.\n */\n\nconst CONTINUE = true;\n/**\n * Stop traversing immediately.\n */\n\nconst EXIT = false;\n/**\n * Do not traverse this nodeâ€™s children.\n */\n\nconst SKIP = 'skip';\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\n\nconst visitParents =\n/**\n * @type {(\n *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n * )}\n */\n\n/**\n * @param {Node} tree\n * @param {Test} test\n * @param {Visitor<Node>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {void}\n */\nfunction (tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor; // @ts-expect-error no visitor given, so `visitor` is test.\n\n    visitor = test;\n    test = null;\n  }\n\n  const is = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)(test);\n  const step = reverse ? -1 : 1;\n  factory(tree, undefined, [])();\n  /**\n   * @param {Node} node\n   * @param {number | undefined} index\n   * @param {Array<Parent>} parents\n   */\n\n  function factory(node, index, parents) {\n    /** @type {Record<string, unknown>} */\n    // @ts-expect-error: hush\n    const value = node && typeof node === 'object' ? node : {};\n\n    if (typeof value.type === 'string') {\n      const name = // `hast`\n      typeof value.tagName === 'string' ? value.tagName : // `xast`\n      typeof value.name === 'string' ? value.name : undefined;\n      Object.defineProperty(visit, 'name', {\n        value: 'node (' + (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.color)(node.type + (name ? '<' + name + '>' : '')) + ')'\n      });\n    }\n\n    return visit;\n\n    function visit() {\n      /** @type {ActionTuple} */\n      let result = [];\n      /** @type {ActionTuple} */\n\n      let subresult;\n      /** @type {number} */\n\n      let offset;\n      /** @type {Array<Parent>} */\n\n      let grandparents;\n\n      if (!test || is(node, index, parents[parents.length - 1] || null)) {\n        result = toResult(visitor(node, parents));\n\n        if (result[0] === EXIT) {\n          return result;\n        }\n      } // @ts-expect-error looks like a parent.\n\n\n      if (node.children && result[0] !== SKIP) {\n        // @ts-expect-error looks like a parent.\n        offset = (reverse ? node.children.length : -1) + step; // @ts-expect-error looks like a parent.\n\n        grandparents = parents.concat(node); // @ts-expect-error looks like a parent.\n\n        while (offset > -1 && offset < node.children.length) {\n          // @ts-expect-error looks like a parent.\n          subresult = factory(node.children[offset], offset, grandparents)();\n\n          if (subresult[0] === EXIT) {\n            return subresult;\n          }\n\n          offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;\n        }\n      }\n\n      return result;\n    }\n  }\n};\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\n\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value];\n  }\n\n  return [value];\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/unist-util-visit-parents/lib/index.js?");

/***/ }),

/***/ "./node_modules/unist-util-visit/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/unist-util-visit/lib/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONTINUE\": function() { return /* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.CONTINUE; },\n/* harmony export */   \"EXIT\": function() { return /* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.EXIT; },\n/* harmony export */   \"SKIP\": function() { return /* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.SKIP; },\n/* harmony export */   \"visit\": function() { return /* binding */ visit; }\n/* harmony export */ });\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit-parents */ \"./node_modules/unist-util-visit-parents/lib/index.js\");\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\n\nconst visit =\n/**\n * @type {(\n *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n * )}\n */\n\n/**\n * @param {Node} tree\n * @param {Test} test\n * @param {Visitor} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {void}\n */\nfunction (tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor;\n    visitor = test;\n    test = null;\n  }\n\n  (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.visitParents)(tree, test, overload, reverse);\n  /**\n   * @param {Node} node\n   * @param {Array<Parent>} parents\n   */\n\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1];\n    return visitor(node, parent ? parent.children.indexOf(node) : null, parent);\n  }\n};\n\n\n//# sourceURL=webpack://vadmin-front/./node_modules/unist-util-visit/lib/index.js?");

/***/ }),

/***/ "./node_modules/uvu/assert/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/uvu/assert/index.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Assertion\": function() { return /* binding */ Assertion; },\n/* harmony export */   \"equal\": function() { return /* binding */ equal; },\n/* harmony export */   \"fixture\": function() { return /* binding */ fixture; },\n/* harmony export */   \"instance\": function() { return /* binding */ instance; },\n/* harmony export */   \"is\": function() { return /* binding */ is; },\n/* harmony export */   \"match\": function() { return /* binding */ match; },\n/* harmony export */   \"not\": function() { return /* binding */ not; },\n/* harmony export */   \"ok\": function() { return /* binding */ ok; },\n/* harmony export */   \"snapshot\": function() { return /* binding */ snapshot; },\n/* harmony export */   \"throws\": function() { return /* binding */ throws; },\n/* harmony export */   \"type\": function() { return /* binding */ type; },\n/* harmony export */   \"unreachable\": function() { return /* binding */ unreachable; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n/* harmony import */ var dequal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dequal */ \"./node_modules/dequal/dist/index.mjs\");\n/* harmony import */ var uvu_diff__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uvu/diff */ \"./node_modules/uvu/diff/index.mjs\");\n\n\n\n\nfunction dedent(str) {\n  str = str.replace(/\\r?\\n/g, '\\n');\n  let arr = str.match(/^[ \\t]*(?=\\S)/gm);\n  let i = 0,\n      min = 1 / 0,\n      len = (arr || []).length;\n\n  for (; i < len; i++) min = Math.min(min, arr[i].length);\n\n  return len && min ? str.replace(new RegExp(`^[ \\\\t]{${min}}`, 'gm'), '') : str;\n}\n\nclass Assertion extends Error {\n  constructor(opts = {}) {\n    super(opts.message);\n    this.name = 'Assertion';\n    this.code = 'ERR_ASSERTION';\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.details = opts.details || false;\n    this.generated = !!opts.generated;\n    this.operator = opts.operator;\n    this.expects = opts.expects;\n    this.actual = opts.actual;\n  }\n\n}\n\nfunction assert(bool, actual, expects, operator, detailer, backup, msg) {\n  if (bool) return;\n  let message = msg || backup;\n  if (msg instanceof Error) throw msg;\n  let details = detailer && detailer(actual, expects);\n  throw new Assertion({\n    actual,\n    expects,\n    operator,\n    message,\n    details,\n    generated: !msg\n  });\n}\n\nfunction ok(val, msg) {\n  assert(!!val, false, true, 'ok', false, 'Expected value to be truthy', msg);\n}\nfunction is(val, exp, msg) {\n  assert(val === exp, val, exp, 'is', uvu_diff__WEBPACK_IMPORTED_MODULE_2__.compare, 'Expected values to be strictly equal:', msg);\n}\nfunction equal(val, exp, msg) {\n  assert((0,dequal__WEBPACK_IMPORTED_MODULE_1__.dequal)(val, exp), val, exp, 'equal', uvu_diff__WEBPACK_IMPORTED_MODULE_2__.compare, 'Expected values to be deeply equal:', msg);\n}\nfunction unreachable(msg) {\n  assert(false, true, false, 'unreachable', false, 'Expected not to be reached!', msg);\n}\nfunction type(val, exp, msg) {\n  let tmp = typeof val;\n  assert(tmp === exp, tmp, exp, 'type', false, `Expected \"${tmp}\" to be \"${exp}\"`, msg);\n}\nfunction instance(val, exp, msg) {\n  let name = '`' + (exp.name || exp.constructor.name) + '`';\n  assert(val instanceof exp, val, exp, 'instance', false, `Expected value to be an instance of ${name}`, msg);\n}\nfunction match(val, exp, msg) {\n  if (typeof exp === 'string') {\n    assert(val.includes(exp), val, exp, 'match', false, `Expected value to include \"${exp}\" substring`, msg);\n  } else {\n    assert(exp.test(val), val, exp, 'match', false, `Expected value to match \\`${String(exp)}\\` pattern`, msg);\n  }\n}\nfunction snapshot(val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val === exp, val, exp, 'snapshot', uvu_diff__WEBPACK_IMPORTED_MODULE_2__.lines, 'Expected value to match snapshot:', msg);\n}\n\nconst lineNums = (x, y) => (0,uvu_diff__WEBPACK_IMPORTED_MODULE_2__.lines)(x, y, 1);\n\nfunction fixture(val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val === exp, val, exp, 'fixture', lineNums, 'Expected value to match fixture:', msg);\n}\nfunction throws(blk, exp, msg) {\n  if (!msg && typeof exp === 'string') {\n    msg = exp;\n    exp = null;\n  }\n\n  try {\n    blk();\n    assert(false, false, true, 'throws', false, 'Expected function to throw', msg);\n  } catch (err) {\n    if (err instanceof Assertion) throw err;\n\n    if (typeof exp === 'function') {\n      assert(exp(err), false, true, 'throws', false, 'Expected function to throw matching exception', msg);\n    } else if (exp instanceof RegExp) {\n      assert(exp.test(err.message), false, true, 'throws', false, `Expected function to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n    }\n  }\n} // ---\n\nfunction not(val, msg) {\n  assert(!val, true, false, 'not', false, 'Expected value to be falsey', msg);\n}\nnot.ok = not;\n\nis.not = function (val, exp, msg) {\n  assert(val !== exp, val, exp, 'is.not', false, 'Expected values not to be strictly equal', msg);\n};\n\nnot.equal = function (val, exp, msg) {\n  assert(!(0,dequal__WEBPACK_IMPORTED_MODULE_1__.dequal)(val, exp), val, exp, 'not.equal', false, 'Expected values not to be deeply equal', msg);\n};\n\nnot.type = function (val, exp, msg) {\n  let tmp = typeof val;\n  assert(tmp !== exp, tmp, exp, 'not.type', false, `Expected \"${tmp}\" not to be \"${exp}\"`, msg);\n};\n\nnot.instance = function (val, exp, msg) {\n  let name = '`' + (exp.name || exp.constructor.name) + '`';\n  assert(!(val instanceof exp), val, exp, 'not.instance', false, `Expected value not to be an instance of ${name}`, msg);\n};\n\nnot.snapshot = function (val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val !== exp, val, exp, 'not.snapshot', false, 'Expected value not to match snapshot', msg);\n};\n\nnot.fixture = function (val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val !== exp, val, exp, 'not.fixture', false, 'Expected value not to match fixture', msg);\n};\n\nnot.match = function (val, exp, msg) {\n  if (typeof exp === 'string') {\n    assert(!val.includes(exp), val, exp, 'not.match', false, `Expected value not to include \"${exp}\" substring`, msg);\n  } else {\n    assert(!exp.test(val), val, exp, 'not.match', false, `Expected value not to match \\`${String(exp)}\\` pattern`, msg);\n  }\n};\n\nnot.throws = function (blk, exp, msg) {\n  if (!msg && typeof exp === 'string') {\n    msg = exp;\n    exp = null;\n  }\n\n  try {\n    blk();\n  } catch (err) {\n    if (typeof exp === 'function') {\n      assert(!exp(err), true, false, 'not.throws', false, 'Expected function not to throw matching exception', msg);\n    } else if (exp instanceof RegExp) {\n      assert(!exp.test(err.message), true, false, 'not.throws', false, `Expected function not to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n    } else if (!exp) {\n      assert(false, true, false, 'not.throws', false, 'Expected function not to throw', msg);\n    }\n  }\n};\n\n//# sourceURL=webpack://vadmin-front/./node_modules/uvu/assert/index.mjs?");

/***/ }),

/***/ "./node_modules/uvu/diff/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/uvu/diff/index.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arrays\": function() { return /* binding */ arrays; },\n/* harmony export */   \"chars\": function() { return /* binding */ chars; },\n/* harmony export */   \"circular\": function() { return /* binding */ circular; },\n/* harmony export */   \"compare\": function() { return /* binding */ compare; },\n/* harmony export */   \"direct\": function() { return /* binding */ direct; },\n/* harmony export */   \"lines\": function() { return /* binding */ lines; },\n/* harmony export */   \"sort\": function() { return /* binding */ sort; },\n/* harmony export */   \"stringify\": function() { return /* binding */ stringify; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var kleur__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! kleur */ \"./node_modules/kleur/index.mjs\");\n/* harmony import */ var diff__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diff */ \"./node_modules/diff/lib/index.mjs\");\n\n\n\nconst colors = {\n  '--': kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].red,\n  'Â·Â·': kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].grey,\n  '++': kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].green\n};\nconst TITLE = kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dim().italic;\nconst TAB = kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dim('â†’'),\n      SPACE = kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dim('Â·'),\n      NL = kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dim('â†µ');\n\nconst LOG = (sym, str) => colors[sym](sym + PRETTY(str)) + '\\n';\n\nconst LINE = (num, x) => kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dim('L' + String(num).padStart(x, '0') + ' ');\n\nconst PRETTY = str => str.replace(/[ ]/g, SPACE).replace(/\\t/g, TAB).replace(/(\\r?\\n)/g, NL);\n\nfunction line(obj, prev, pad) {\n  let char = obj.removed ? '--' : obj.added ? '++' : 'Â·Â·';\n  let arr = obj.value.replace(/\\r?\\n$/, '').split('\\n');\n  let i = 0,\n      tmp,\n      out = '';\n  if (obj.added) out += colors[char]().underline(TITLE('Expected:')) + '\\n';else if (obj.removed) out += colors[char]().underline(TITLE('Actual:')) + '\\n';\n\n  for (; i < arr.length; i++) {\n    tmp = arr[i];\n\n    if (tmp != null) {\n      if (prev) out += LINE(prev + i, pad);\n      out += LOG(char, tmp || '\\n');\n    }\n  }\n\n  return out;\n} // TODO: want better diffing\n//~> complex items bail outright\n\n\nfunction arrays(input, expect) {\n  let arr = diff__WEBPACK_IMPORTED_MODULE_2__.diffArrays(input, expect);\n  let i = 0,\n      j = 0,\n      k = 0,\n      tmp,\n      val,\n      char,\n      isObj,\n      str;\n  let out = LOG('Â·Â·', '[');\n\n  for (; i < arr.length; i++) {\n    char = (tmp = arr[i]).removed ? '--' : tmp.added ? '++' : 'Â·Â·';\n\n    if (tmp.added) {\n      out += colors[char]().underline(TITLE('Expected:')) + '\\n';\n    } else if (tmp.removed) {\n      out += colors[char]().underline(TITLE('Actual:')) + '\\n';\n    }\n\n    for (j = 0; j < tmp.value.length; j++) {\n      isObj = tmp.value[j] && typeof tmp.value[j] === 'object';\n      val = stringify(tmp.value[j]).split(/\\r?\\n/g);\n\n      for (k = 0; k < val.length;) {\n        str = '  ' + val[k++] + (isObj ? '' : ',');\n        if (isObj && k === val.length && j + 1 < tmp.value.length) str += ',';\n        out += LOG(char, str);\n      }\n    }\n  }\n\n  return out + LOG('Â·Â·', ']');\n}\nfunction lines(input, expect, linenum = 0) {\n  let i = 0,\n      tmp,\n      output = '';\n  let arr = diff__WEBPACK_IMPORTED_MODULE_2__.diffLines(input, expect);\n  let pad = String(expect.split(/\\r?\\n/g).length - linenum).length;\n\n  for (; i < arr.length; i++) {\n    output += line(tmp = arr[i], linenum, pad);\n    if (linenum && !tmp.removed) linenum += tmp.count;\n  }\n\n  return output;\n}\nfunction chars(input, expect) {\n  let arr = diff__WEBPACK_IMPORTED_MODULE_2__.diffChars(input, expect);\n  let i = 0,\n      output = '',\n      tmp;\n  let l1 = input.length;\n  let l2 = expect.length;\n  let p1 = PRETTY(input);\n  let p2 = PRETTY(expect);\n  tmp = arr[i];\n\n  if (l1 === l2) {// no length offsets\n  } else if (tmp.removed && arr[i + 1]) {\n    let del = tmp.count - arr[i + 1].count;\n\n    if (del == 0) {// wash~\n    } else if (del > 0) {\n      expect = ' '.repeat(del) + expect;\n      p2 = ' '.repeat(del) + p2;\n      l2 += del;\n    } else if (del < 0) {\n      input = ' '.repeat(-del) + input;\n      p1 = ' '.repeat(-del) + p1;\n      l1 += -del;\n    }\n  }\n\n  output += direct(p1, p2, l1, l2);\n\n  if (l1 === l2) {\n    for (tmp = '  '; i < l1; i++) {\n      tmp += input[i] === expect[i] ? ' ' : '^';\n    }\n  } else {\n    for (tmp = '  '; i < arr.length; i++) {\n      tmp += (arr[i].added || arr[i].removed ? '^' : ' ').repeat(Math.max(arr[i].count, 0));\n\n      if (i + 1 < arr.length && (arr[i].added && arr[i + 1].removed || arr[i].removed && arr[i + 1].added)) {\n        arr[i + 1].count -= arr[i].count;\n      }\n    }\n  }\n\n  return output + kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].red(tmp);\n}\nfunction direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {\n  let gutter = 4;\n  let lenC = Math.max(lenA, lenB);\n  let typeA = typeof input,\n      typeB = typeof expect;\n\n  if (typeA !== typeB) {\n    gutter = 2;\n    let delA = gutter + lenC - lenA;\n    let delB = gutter + lenC - lenB;\n    input += ' '.repeat(delA) + kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dim(`[${typeA}]`);\n    expect += ' '.repeat(delB) + kleur__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dim(`[${typeB}]`);\n    lenA += delA + typeA.length + 2;\n    lenB += delB + typeB.length + 2;\n    lenC = Math.max(lenA, lenB);\n  }\n\n  let output = colors['++']('++' + expect + ' '.repeat(gutter + lenC - lenB) + TITLE('(Expected)')) + '\\n';\n  return output + colors['--']('--' + input + ' '.repeat(gutter + lenC - lenA) + TITLE('(Actual)')) + '\\n';\n}\nfunction sort(input, expect) {\n  var k,\n      i = 0,\n      tmp,\n      isArr = Array.isArray(input);\n  var keys = [],\n      out = isArr ? Array(input.length) : {};\n\n  if (isArr) {\n    for (i = 0; i < out.length; i++) {\n      tmp = input[i];\n      if (!tmp || typeof tmp !== 'object') out[i] = tmp;else out[i] = sort(tmp, expect[i]); // might not be right\n    }\n  } else {\n    for (k in expect) keys.push(k);\n\n    for (; i < keys.length; i++) {\n      if (Object.prototype.hasOwnProperty.call(input, k = keys[i])) {\n        if (!(tmp = input[k]) || typeof tmp !== 'object') out[k] = tmp;else out[k] = sort(tmp, expect[k]);\n      }\n    }\n\n    for (k in input) {\n      if (!out.hasOwnProperty(k)) {\n        out[k] = input[k]; // expect didnt have\n      }\n    }\n  }\n\n  return out;\n}\nfunction circular() {\n  var cache = new Set();\n  return function print(key, val) {\n    if (val === void 0) return '[__VOID__]';\n    if (typeof val === 'number' && val !== val) return '[__NAN__]';\n    if (typeof val === 'bigint') return val.toString();\n    if (!val || typeof val !== 'object') return val;\n    if (cache.has(val)) return '[Circular]';\n    cache.add(val);\n    return val;\n  };\n}\nfunction stringify(input) {\n  return JSON.stringify(input, circular(), 2).replace(/\"\\[__NAN__\\]\"/g, 'NaN').replace(/\"\\[__VOID__\\]\"/g, 'undefined');\n}\nfunction compare(input, expect) {\n  if (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect);\n  if (expect instanceof RegExp) return chars('' + input, '' + expect);\n  let isA = input && typeof input == 'object';\n  let isB = expect && typeof expect == 'object';\n  if (isA && isB) input = sort(input, expect);\n  if (isB) expect = stringify(expect);\n  if (isA) input = stringify(input);\n\n  if (expect && typeof expect == 'object') {\n    input = stringify(sort(input, expect));\n    expect = stringify(expect);\n  }\n\n  isA = typeof input == 'string';\n  isB = typeof expect == 'string';\n  if (isA && /\\r?\\n/.test(input)) return lines(input, '' + expect);\n  if (isB && /\\r?\\n/.test(expect)) return lines('' + input, expect);\n  if (isA && isB) return chars(input, expect);\n  return direct(input, expect);\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/uvu/diff/index.mjs?");

/***/ })

}]);
"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkvadmin_front"] = self["webpackChunkvadmin_front"] || []).push([["vendors-node_modules_hast-util-raw_node_modules_parse5_lib_extensions_error-reporting_parser--728080"],{

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js ***!
  \*****************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js\");\n\nclass ErrorReportingMixinBase extends Mixin {\n  constructor(host, opts) {\n    super(host);\n    this.posTracker = null;\n    this.onParseError = opts.onParseError;\n  }\n\n  _setErrorLocation(err) {\n    err.startLine = err.endLine = this.posTracker.line;\n    err.startCol = err.endCol = this.posTracker.col;\n    err.startOffset = err.endOffset = this.posTracker.offset;\n  }\n\n  _reportError(code) {\n    const err = {\n      code: code,\n      startLine: -1,\n      startCol: -1,\n      startOffset: -1,\n      endLine: -1,\n      endCol: -1,\n      endOffset: -1\n    };\n\n    this._setErrorLocation(err);\n\n    this.onParseError(err);\n  }\n\n  _getOverriddenMethods(mxn) {\n    return {\n      _err(code) {\n        mxn._reportError(code);\n      }\n\n    };\n  }\n\n}\n\nmodule.exports = ErrorReportingMixinBase;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js ***!
  \*******************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst ErrorReportingMixinBase = __webpack_require__(/*! ./mixin-base */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js\");\n\nconst ErrorReportingTokenizerMixin = __webpack_require__(/*! ./tokenizer-mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js\");\n\nconst LocationInfoTokenizerMixin = __webpack_require__(/*! ../location-info/tokenizer-mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js\");\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js\");\n\nclass ErrorReportingParserMixin extends ErrorReportingMixinBase {\n  constructor(parser, opts) {\n    super(parser, opts);\n    this.opts = opts;\n    this.ctLoc = null;\n    this.locBeforeToken = false;\n  }\n\n  _setErrorLocation(err) {\n    if (this.ctLoc) {\n      err.startLine = this.ctLoc.startLine;\n      err.startCol = this.ctLoc.startCol;\n      err.startOffset = this.ctLoc.startOffset;\n      err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;\n      err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;\n      err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;\n    }\n  }\n\n  _getOverriddenMethods(mxn, orig) {\n    return {\n      _bootstrap(document, fragmentContext) {\n        orig._bootstrap.call(this, document, fragmentContext);\n\n        Mixin.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);\n        Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n      },\n\n      _processInputToken(token) {\n        mxn.ctLoc = token.location;\n\n        orig._processInputToken.call(this, token);\n      },\n\n      _err(code, options) {\n        mxn.locBeforeToken = options && options.beforeToken;\n\n        mxn._reportError(code);\n      }\n\n    };\n  }\n\n}\n\nmodule.exports = ErrorReportingParserMixin;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js ***!
  \*************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst ErrorReportingMixinBase = __webpack_require__(/*! ./mixin-base */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js\");\n\nconst PositionTrackingPreprocessorMixin = __webpack_require__(/*! ../position-tracking/preprocessor-mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js\");\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js\");\n\nclass ErrorReportingPreprocessorMixin extends ErrorReportingMixinBase {\n  constructor(preprocessor, opts) {\n    super(preprocessor, opts);\n    this.posTracker = Mixin.install(preprocessor, PositionTrackingPreprocessorMixin);\n    this.lastErrOffset = -1;\n  }\n\n  _reportError(code) {\n    //NOTE: avoid reporting error twice on advance/retreat\n    if (this.lastErrOffset !== this.posTracker.offset) {\n      this.lastErrOffset = this.posTracker.offset;\n\n      super._reportError(code);\n    }\n  }\n\n}\n\nmodule.exports = ErrorReportingPreprocessorMixin;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js ***!
  \**********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst ErrorReportingMixinBase = __webpack_require__(/*! ./mixin-base */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js\");\n\nconst ErrorReportingPreprocessorMixin = __webpack_require__(/*! ./preprocessor-mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js\");\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js\");\n\nclass ErrorReportingTokenizerMixin extends ErrorReportingMixinBase {\n  constructor(tokenizer, opts) {\n    super(tokenizer, opts);\n    const preprocessorMixin = Mixin.install(tokenizer.preprocessor, ErrorReportingPreprocessorMixin, opts);\n    this.posTracker = preprocessorMixin.posTracker;\n  }\n\n}\n\nmodule.exports = ErrorReportingTokenizerMixin;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js ***!
  \*****************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js\");\n\nclass LocationInfoOpenElementStackMixin extends Mixin {\n  constructor(stack, opts) {\n    super(stack);\n    this.onItemPop = opts.onItemPop;\n  }\n\n  _getOverriddenMethods(mxn, orig) {\n    return {\n      pop() {\n        mxn.onItemPop(this.current);\n        orig.pop.call(this);\n      },\n\n      popAllUpToHtmlElement() {\n        for (let i = this.stackTop; i > 0; i--) {\n          mxn.onItemPop(this.items[i]);\n        }\n\n        orig.popAllUpToHtmlElement.call(this);\n      },\n\n      remove(element) {\n        mxn.onItemPop(this.current);\n        orig.remove.call(this, element);\n      }\n\n    };\n  }\n\n}\n\nmodule.exports = LocationInfoOpenElementStackMixin;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/parser-mixin.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/parser-mixin.js ***!
  \*****************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js\");\n\nconst Tokenizer = __webpack_require__(/*! ../../tokenizer */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/index.js\");\n\nconst LocationInfoTokenizerMixin = __webpack_require__(/*! ./tokenizer-mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js\");\n\nconst LocationInfoOpenElementStackMixin = __webpack_require__(/*! ./open-element-stack-mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js\");\n\nconst HTML = __webpack_require__(/*! ../../common/html */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/common/html.js\"); //Aliases\n\n\nconst $ = HTML.TAG_NAMES;\n\nclass LocationInfoParserMixin extends Mixin {\n  constructor(parser) {\n    super(parser);\n    this.parser = parser;\n    this.treeAdapter = this.parser.treeAdapter;\n    this.posTracker = null;\n    this.lastStartTagToken = null;\n    this.lastFosterParentingLocation = null;\n    this.currentToken = null;\n  }\n\n  _setStartLocation(element) {\n    let loc = null;\n\n    if (this.lastStartTagToken) {\n      loc = Object.assign({}, this.lastStartTagToken.location);\n      loc.startTag = this.lastStartTagToken.location;\n    }\n\n    this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n  }\n\n  _setEndLocation(element, closingToken) {\n    const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n    if (loc) {\n      if (closingToken.location) {\n        const ctLoc = closingToken.location;\n        const tn = this.treeAdapter.getTagName(element); // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n\n        const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n        const endLoc = {};\n\n        if (isClosingEndTag) {\n          endLoc.endTag = Object.assign({}, ctLoc);\n          endLoc.endLine = ctLoc.endLine;\n          endLoc.endCol = ctLoc.endCol;\n          endLoc.endOffset = ctLoc.endOffset;\n        } else {\n          endLoc.endLine = ctLoc.startLine;\n          endLoc.endCol = ctLoc.startCol;\n          endLoc.endOffset = ctLoc.startOffset;\n        }\n\n        this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\n      }\n    }\n  }\n\n  _getOverriddenMethods(mxn, orig) {\n    return {\n      _bootstrap(document, fragmentContext) {\n        orig._bootstrap.call(this, document, fragmentContext);\n\n        mxn.lastStartTagToken = null;\n        mxn.lastFosterParentingLocation = null;\n        mxn.currentToken = null;\n        const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n        mxn.posTracker = tokenizerMixin.posTracker;\n        Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n          onItemPop: function (element) {\n            mxn._setEndLocation(element, mxn.currentToken);\n          }\n        });\n      },\n\n      _runParsingLoop(scriptHandler) {\n        orig._runParsingLoop.call(this, scriptHandler); // NOTE: generate location info for elements\n        // that remains on open element stack\n\n\n        for (let i = this.openElements.stackTop; i >= 0; i--) {\n          mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n        }\n      },\n\n      //Token processing\n      _processTokenInForeignContent(token) {\n        mxn.currentToken = token;\n\n        orig._processTokenInForeignContent.call(this, token);\n      },\n\n      _processToken(token) {\n        mxn.currentToken = token;\n\n        orig._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n        //their end location explicitly.\n\n\n        const requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));\n\n        if (requireExplicitUpdate) {\n          for (let i = this.openElements.stackTop; i >= 0; i--) {\n            const element = this.openElements.items[i];\n\n            if (this.treeAdapter.getTagName(element) === token.tagName) {\n              mxn._setEndLocation(element, token);\n\n              break;\n            }\n          }\n        }\n      },\n\n      //Doctype\n      _setDocumentType(token) {\n        orig._setDocumentType.call(this, token);\n\n        const documentChildren = this.treeAdapter.getChildNodes(this.document);\n        const cnLength = documentChildren.length;\n\n        for (let i = 0; i < cnLength; i++) {\n          const node = documentChildren[i];\n\n          if (this.treeAdapter.isDocumentTypeNode(node)) {\n            this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n            break;\n          }\n        }\n      },\n\n      //Elements\n      _attachElementToTree(element) {\n        //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n        //So we will use token location stored in this methods for the element.\n        mxn._setStartLocation(element);\n\n        mxn.lastStartTagToken = null;\n\n        orig._attachElementToTree.call(this, element);\n      },\n\n      _appendElement(token, namespaceURI) {\n        mxn.lastStartTagToken = token;\n\n        orig._appendElement.call(this, token, namespaceURI);\n      },\n\n      _insertElement(token, namespaceURI) {\n        mxn.lastStartTagToken = token;\n\n        orig._insertElement.call(this, token, namespaceURI);\n      },\n\n      _insertTemplate(token) {\n        mxn.lastStartTagToken = token;\n\n        orig._insertTemplate.call(this, token);\n\n        const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n        this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n      },\n\n      _insertFakeRootElement() {\n        orig._insertFakeRootElement.call(this);\n\n        this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n      },\n\n      //Comments\n      _appendCommentNode(token, parent) {\n        orig._appendCommentNode.call(this, token, parent);\n\n        const children = this.treeAdapter.getChildNodes(parent);\n        const commentNode = children[children.length - 1];\n        this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n      },\n\n      //Text\n      _findFosterParentingLocation() {\n        //NOTE: store last foster parenting location, so we will be able to find inserted text\n        //in case of foster parenting\n        mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n        return mxn.lastFosterParentingLocation;\n      },\n\n      _insertCharacters(token) {\n        orig._insertCharacters.call(this, token);\n\n        const hasFosterParent = this._shouldFosterParentOnInsertion();\n\n        const parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;\n        const siblings = this.treeAdapter.getChildNodes(parent);\n        const textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;\n        const textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position\n\n        const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n        if (tnLoc) {\n          const {\n            endLine,\n            endCol,\n            endOffset\n          } = token.location;\n          this.treeAdapter.updateNodeSourceCodeLocation(textNode, {\n            endLine,\n            endCol,\n            endOffset\n          });\n        } else {\n          this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n        }\n      }\n\n    };\n  }\n\n}\n\nmodule.exports = LocationInfoParserMixin;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/parser-mixin.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js ***!
  \********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js\");\n\nconst Tokenizer = __webpack_require__(/*! ../../tokenizer */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/index.js\");\n\nconst PositionTrackingPreprocessorMixin = __webpack_require__(/*! ../position-tracking/preprocessor-mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js\");\n\nclass LocationInfoTokenizerMixin extends Mixin {\n  constructor(tokenizer) {\n    super(tokenizer);\n    this.tokenizer = tokenizer;\n    this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);\n    this.currentAttrLocation = null;\n    this.ctLoc = null;\n  }\n\n  _getCurrentLocation() {\n    return {\n      startLine: this.posTracker.line,\n      startCol: this.posTracker.col,\n      startOffset: this.posTracker.offset,\n      endLine: -1,\n      endCol: -1,\n      endOffset: -1\n    };\n  }\n\n  _attachCurrentAttrLocationInfo() {\n    this.currentAttrLocation.endLine = this.posTracker.line;\n    this.currentAttrLocation.endCol = this.posTracker.col;\n    this.currentAttrLocation.endOffset = this.posTracker.offset;\n    const currentToken = this.tokenizer.currentToken;\n    const currentAttr = this.tokenizer.currentAttr;\n\n    if (!currentToken.location.attrs) {\n      currentToken.location.attrs = Object.create(null);\n    }\n\n    currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;\n  }\n\n  _getOverriddenMethods(mxn, orig) {\n    const methods = {\n      _createStartTagToken() {\n        orig._createStartTagToken.call(this);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createEndTagToken() {\n        orig._createEndTagToken.call(this);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createCommentToken() {\n        orig._createCommentToken.call(this);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createDoctypeToken(initialName) {\n        orig._createDoctypeToken.call(this, initialName);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createCharacterToken(type, ch) {\n        orig._createCharacterToken.call(this, type, ch);\n\n        this.currentCharacterToken.location = mxn.ctLoc;\n      },\n\n      _createEOFToken() {\n        orig._createEOFToken.call(this);\n\n        this.currentToken.location = mxn._getCurrentLocation();\n      },\n\n      _createAttr(attrNameFirstCh) {\n        orig._createAttr.call(this, attrNameFirstCh);\n\n        mxn.currentAttrLocation = mxn._getCurrentLocation();\n      },\n\n      _leaveAttrName(toState) {\n        orig._leaveAttrName.call(this, toState);\n\n        mxn._attachCurrentAttrLocationInfo();\n      },\n\n      _leaveAttrValue(toState) {\n        orig._leaveAttrValue.call(this, toState);\n\n        mxn._attachCurrentAttrLocationInfo();\n      },\n\n      _emitCurrentToken() {\n        const ctLoc = this.currentToken.location; //NOTE: if we have pending character token make it's end location equal to the\n        //current token's start location.\n\n        if (this.currentCharacterToken) {\n          this.currentCharacterToken.location.endLine = ctLoc.startLine;\n          this.currentCharacterToken.location.endCol = ctLoc.startCol;\n          this.currentCharacterToken.location.endOffset = ctLoc.startOffset;\n        }\n\n        if (this.currentToken.type === Tokenizer.EOF_TOKEN) {\n          ctLoc.endLine = ctLoc.startLine;\n          ctLoc.endCol = ctLoc.startCol;\n          ctLoc.endOffset = ctLoc.startOffset;\n        } else {\n          ctLoc.endLine = mxn.posTracker.line;\n          ctLoc.endCol = mxn.posTracker.col + 1;\n          ctLoc.endOffset = mxn.posTracker.offset + 1;\n        }\n\n        orig._emitCurrentToken.call(this);\n      },\n\n      _emitCurrentCharacterToken() {\n        const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location; //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n        //then set it's location at the current preprocessor position.\n        //We don't need to increment preprocessor position, since character token\n        //emission is always forced by the start of the next character token here.\n        //So, we already have advanced position.\n\n        if (ctLoc && ctLoc.endOffset === -1) {\n          ctLoc.endLine = mxn.posTracker.line;\n          ctLoc.endCol = mxn.posTracker.col;\n          ctLoc.endOffset = mxn.posTracker.offset;\n        }\n\n        orig._emitCurrentCharacterToken.call(this);\n      }\n\n    }; //NOTE: patch initial states for each mode to obtain token start position\n\n    Object.keys(Tokenizer.MODE).forEach(modeName => {\n      const state = Tokenizer.MODE[modeName];\n\n      methods[state] = function (cp) {\n        mxn.ctLoc = mxn._getCurrentLocation();\n        orig[state].call(this, cp);\n      };\n    });\n    return methods;\n  }\n\n}\n\nmodule.exports = LocationInfoTokenizerMixin;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js ***!
  \***************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js\");\n\nclass PositionTrackingPreprocessorMixin extends Mixin {\n  constructor(preprocessor) {\n    super(preprocessor);\n    this.preprocessor = preprocessor;\n    this.isEol = false;\n    this.lineStartPos = 0;\n    this.droppedBufferSize = 0;\n    this.offset = 0;\n    this.col = 0;\n    this.line = 1;\n  }\n\n  _getOverriddenMethods(mxn, orig) {\n    return {\n      advance() {\n        const pos = this.pos + 1;\n        const ch = this.html[pos]; //NOTE: LF should be in the last column of the line\n\n        if (mxn.isEol) {\n          mxn.isEol = false;\n          mxn.line++;\n          mxn.lineStartPos = pos;\n        }\n\n        if (ch === '\\n' || ch === '\\r' && this.html[pos + 1] !== '\\n') {\n          mxn.isEol = true;\n        }\n\n        mxn.col = pos - mxn.lineStartPos + 1;\n        mxn.offset = mxn.droppedBufferSize + pos;\n        return orig.advance.call(this);\n      },\n\n      retreat() {\n        orig.retreat.call(this);\n        mxn.isEol = false;\n        mxn.col = this.pos - mxn.lineStartPos + 1;\n      },\n\n      dropParsedChunk() {\n        const prevPos = this.pos;\n        orig.dropParsedChunk.call(this);\n        const reduction = prevPos - this.pos;\n        mxn.lineStartPos -= reduction;\n        mxn.droppedBufferSize += reduction;\n        mxn.offset = mxn.droppedBufferSize + this.pos;\n      }\n\n    };\n  }\n\n}\n\nmodule.exports = PositionTrackingPreprocessorMixin;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/parser/formatting-element-list.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/parser/formatting-element-list.js ***!
  \**********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(" //Const\n\n__webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n\nconst NOAH_ARK_CAPACITY = 3; //List of formatting elements\n\nclass FormattingElementList {\n  constructor(treeAdapter) {\n    this.length = 0;\n    this.entries = [];\n    this.treeAdapter = treeAdapter;\n    this.bookmark = null;\n  } //Noah Ark's condition\n  //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n  //lightweight heuristics without thorough attributes check.\n\n\n  _getNoahArkConditionCandidates(newElement) {\n    const candidates = [];\n\n    if (this.length >= NOAH_ARK_CAPACITY) {\n      const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n      const neTagName = this.treeAdapter.getTagName(newElement);\n      const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n      for (let i = this.length - 1; i >= 0; i--) {\n        const entry = this.entries[i];\n\n        if (entry.type === FormattingElementList.MARKER_ENTRY) {\n          break;\n        }\n\n        const element = entry.element;\n        const elementAttrs = this.treeAdapter.getAttrList(element);\n        const isCandidate = this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI && elementAttrs.length === neAttrsLength;\n\n        if (isCandidate) {\n          candidates.push({\n            idx: i,\n            attrs: elementAttrs\n          });\n        }\n      }\n    }\n\n    return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n  }\n\n  _ensureNoahArkCondition(newElement) {\n    const candidates = this._getNoahArkConditionCandidates(newElement);\n\n    let cLength = candidates.length;\n\n    if (cLength) {\n      const neAttrs = this.treeAdapter.getAttrList(newElement);\n      const neAttrsLength = neAttrs.length;\n      const neAttrsMap = Object.create(null); //NOTE: build attrs map for the new element so we can perform fast lookups\n\n      for (let i = 0; i < neAttrsLength; i++) {\n        const neAttr = neAttrs[i];\n        neAttrsMap[neAttr.name] = neAttr.value;\n      }\n\n      for (let i = 0; i < neAttrsLength; i++) {\n        for (let j = 0; j < cLength; j++) {\n          const cAttr = candidates[j].attrs[i];\n\n          if (neAttrsMap[cAttr.name] !== cAttr.value) {\n            candidates.splice(j, 1);\n            cLength--;\n          }\n\n          if (candidates.length < NOAH_ARK_CAPACITY) {\n            return;\n          }\n        }\n      } //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n\n\n      for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n        this.entries.splice(candidates[i].idx, 1);\n        this.length--;\n      }\n    }\n  } //Mutations\n\n\n  insertMarker() {\n    this.entries.push({\n      type: FormattingElementList.MARKER_ENTRY\n    });\n    this.length++;\n  }\n\n  pushElement(element, token) {\n    this._ensureNoahArkCondition(element);\n\n    this.entries.push({\n      type: FormattingElementList.ELEMENT_ENTRY,\n      element: element,\n      token: token\n    });\n    this.length++;\n  }\n\n  insertElementAfterBookmark(element, token) {\n    let bookmarkIdx = this.length - 1;\n\n    for (; bookmarkIdx >= 0; bookmarkIdx--) {\n      if (this.entries[bookmarkIdx] === this.bookmark) {\n        break;\n      }\n    }\n\n    this.entries.splice(bookmarkIdx + 1, 0, {\n      type: FormattingElementList.ELEMENT_ENTRY,\n      element: element,\n      token: token\n    });\n    this.length++;\n  }\n\n  removeEntry(entry) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this.entries[i] === entry) {\n        this.entries.splice(i, 1);\n        this.length--;\n        break;\n      }\n    }\n  }\n\n  clearToLastMarker() {\n    while (this.length) {\n      const entry = this.entries.pop();\n      this.length--;\n\n      if (entry.type === FormattingElementList.MARKER_ENTRY) {\n        break;\n      }\n    }\n  } //Search\n\n\n  getElementEntryInScopeWithTagName(tagName) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      const entry = this.entries[i];\n\n      if (entry.type === FormattingElementList.MARKER_ENTRY) {\n        return null;\n      }\n\n      if (this.treeAdapter.getTagName(entry.element) === tagName) {\n        return entry;\n      }\n    }\n\n    return null;\n  }\n\n  getElementEntry(element) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      const entry = this.entries[i];\n\n      if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n        return entry;\n      }\n    }\n\n    return null;\n  }\n\n} //Entry types\n\n\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\nmodule.exports = FormattingElementList;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/parser/formatting-element-list.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/parser/open-element-stack.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/parser/open-element-stack.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst HTML = __webpack_require__(/*! ../common/html */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/common/html.js\"); //Aliases\n\n\nconst $ = HTML.TAG_NAMES;\nconst NS = HTML.NAMESPACES; //Element utils\n//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.\n//It's faster than using dictionary.\n\nfunction isImpliedEndTagRequired(tn) {\n  switch (tn.length) {\n    case 1:\n      return tn === $.P;\n\n    case 2:\n      return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI;\n\n    case 3:\n      return tn === $.RTC;\n\n    case 6:\n      return tn === $.OPTION;\n\n    case 8:\n      return tn === $.OPTGROUP;\n  }\n\n  return false;\n}\n\nfunction isImpliedEndTagRequiredThoroughly(tn) {\n  switch (tn.length) {\n    case 1:\n      return tn === $.P;\n\n    case 2:\n      return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI || tn === $.TD || tn === $.TH || tn === $.TR;\n\n    case 3:\n      return tn === $.RTC;\n\n    case 5:\n      return tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD;\n\n    case 6:\n      return tn === $.OPTION;\n\n    case 7:\n      return tn === $.CAPTION;\n\n    case 8:\n      return tn === $.OPTGROUP || tn === $.COLGROUP;\n  }\n\n  return false;\n}\n\nfunction isScopingElement(tn, ns) {\n  switch (tn.length) {\n    case 2:\n      if (tn === $.TD || tn === $.TH) {\n        return ns === NS.HTML;\n      } else if (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS) {\n        return ns === NS.MATHML;\n      }\n\n      break;\n\n    case 4:\n      if (tn === $.HTML) {\n        return ns === NS.HTML;\n      } else if (tn === $.DESC) {\n        return ns === NS.SVG;\n      }\n\n      break;\n\n    case 5:\n      if (tn === $.TABLE) {\n        return ns === NS.HTML;\n      } else if (tn === $.MTEXT) {\n        return ns === NS.MATHML;\n      } else if (tn === $.TITLE) {\n        return ns === NS.SVG;\n      }\n\n      break;\n\n    case 6:\n      return (tn === $.APPLET || tn === $.OBJECT) && ns === NS.HTML;\n\n    case 7:\n      return (tn === $.CAPTION || tn === $.MARQUEE) && ns === NS.HTML;\n\n    case 8:\n      return tn === $.TEMPLATE && ns === NS.HTML;\n\n    case 13:\n      return tn === $.FOREIGN_OBJECT && ns === NS.SVG;\n\n    case 14:\n      return tn === $.ANNOTATION_XML && ns === NS.MATHML;\n  }\n\n  return false;\n} //Stack of open elements\n\n\nclass OpenElementStack {\n  constructor(document, treeAdapter) {\n    this.stackTop = -1;\n    this.items = [];\n    this.current = document;\n    this.currentTagName = null;\n    this.currentTmplContent = null;\n    this.tmplCount = 0;\n    this.treeAdapter = treeAdapter;\n  } //Index of element\n\n\n  _indexOf(element) {\n    let idx = -1;\n\n    for (let i = this.stackTop; i >= 0; i--) {\n      if (this.items[i] === element) {\n        idx = i;\n        break;\n      }\n    }\n\n    return idx;\n  } //Update current element\n\n\n  _isInTemplate() {\n    return this.currentTagName === $.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;\n  }\n\n  _updateCurrentElement() {\n    this.current = this.items[this.stackTop];\n    this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);\n    this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;\n  } //Mutations\n\n\n  push(element) {\n    this.items[++this.stackTop] = element;\n\n    this._updateCurrentElement();\n\n    if (this._isInTemplate()) {\n      this.tmplCount++;\n    }\n  }\n\n  pop() {\n    this.stackTop--;\n\n    if (this.tmplCount > 0 && this._isInTemplate()) {\n      this.tmplCount--;\n    }\n\n    this._updateCurrentElement();\n  }\n\n  replace(oldElement, newElement) {\n    const idx = this._indexOf(oldElement);\n\n    this.items[idx] = newElement;\n\n    if (idx === this.stackTop) {\n      this._updateCurrentElement();\n    }\n  }\n\n  insertAfter(referenceElement, newElement) {\n    const insertionIdx = this._indexOf(referenceElement) + 1;\n    this.items.splice(insertionIdx, 0, newElement);\n\n    if (insertionIdx === ++this.stackTop) {\n      this._updateCurrentElement();\n    }\n  }\n\n  popUntilTagNamePopped(tagName) {\n    while (this.stackTop > -1) {\n      const tn = this.currentTagName;\n      const ns = this.treeAdapter.getNamespaceURI(this.current);\n      this.pop();\n\n      if (tn === tagName && ns === NS.HTML) {\n        break;\n      }\n    }\n  }\n\n  popUntilElementPopped(element) {\n    while (this.stackTop > -1) {\n      const poppedElement = this.current;\n      this.pop();\n\n      if (poppedElement === element) {\n        break;\n      }\n    }\n  }\n\n  popUntilNumberedHeaderPopped() {\n    while (this.stackTop > -1) {\n      const tn = this.currentTagName;\n      const ns = this.treeAdapter.getNamespaceURI(this.current);\n      this.pop();\n\n      if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6 && ns === NS.HTML) {\n        break;\n      }\n    }\n  }\n\n  popUntilTableCellPopped() {\n    while (this.stackTop > -1) {\n      const tn = this.currentTagName;\n      const ns = this.treeAdapter.getNamespaceURI(this.current);\n      this.pop();\n\n      if (tn === $.TD || tn === $.TH && ns === NS.HTML) {\n        break;\n      }\n    }\n  }\n\n  popAllUpToHtmlElement() {\n    //NOTE: here we assume that root <html> element is always first in the open element stack, so\n    //we perform this fast stack clean up.\n    this.stackTop = 0;\n\n    this._updateCurrentElement();\n  }\n\n  clearBackToTableContext() {\n    while (this.currentTagName !== $.TABLE && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {\n      this.pop();\n    }\n  }\n\n  clearBackToTableBodyContext() {\n    while (this.currentTagName !== $.TBODY && this.currentTagName !== $.TFOOT && this.currentTagName !== $.THEAD && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {\n      this.pop();\n    }\n  }\n\n  clearBackToTableRowContext() {\n    while (this.currentTagName !== $.TR && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {\n      this.pop();\n    }\n  }\n\n  remove(element) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      if (this.items[i] === element) {\n        this.items.splice(i, 1);\n        this.stackTop--;\n\n        this._updateCurrentElement();\n\n        break;\n      }\n    }\n  } //Search\n\n\n  tryPeekProperlyNestedBodyElement() {\n    //Properly nested <body> element (should be second element in stack).\n    const element = this.items[1];\n    return element && this.treeAdapter.getTagName(element) === $.BODY ? element : null;\n  }\n\n  contains(element) {\n    return this._indexOf(element) > -1;\n  }\n\n  getCommonAncestor(element) {\n    let elementIdx = this._indexOf(element);\n\n    return --elementIdx >= 0 ? this.items[elementIdx] : null;\n  }\n\n  isRootHtmlElementCurrent() {\n    return this.stackTop === 0 && this.currentTagName === $.HTML;\n  } //Element in scope\n\n\n  hasInScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n      if (tn === tagName && ns === NS.HTML) {\n        return true;\n      }\n\n      if (isScopingElement(tn, ns)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  hasNumberedHeaderInScope() {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n      if ((tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) && ns === NS.HTML) {\n        return true;\n      }\n\n      if (isScopingElement(tn, ns)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  hasInListItemScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n      if (tn === tagName && ns === NS.HTML) {\n        return true;\n      }\n\n      if ((tn === $.UL || tn === $.OL) && ns === NS.HTML || isScopingElement(tn, ns)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  hasInButtonScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n      if (tn === tagName && ns === NS.HTML) {\n        return true;\n      }\n\n      if (tn === $.BUTTON && ns === NS.HTML || isScopingElement(tn, ns)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  hasInTableScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n      if (ns !== NS.HTML) {\n        continue;\n      }\n\n      if (tn === tagName) {\n        return true;\n      }\n\n      if (tn === $.TABLE || tn === $.TEMPLATE || tn === $.HTML) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  hasTableBodyContextInTableScope() {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n      if (ns !== NS.HTML) {\n        continue;\n      }\n\n      if (tn === $.TBODY || tn === $.THEAD || tn === $.TFOOT) {\n        return true;\n      }\n\n      if (tn === $.TABLE || tn === $.HTML) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  hasInSelectScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n      if (ns !== NS.HTML) {\n        continue;\n      }\n\n      if (tn === tagName) {\n        return true;\n      }\n\n      if (tn !== $.OPTION && tn !== $.OPTGROUP) {\n        return false;\n      }\n    }\n\n    return true;\n  } //Implied end tags\n\n\n  generateImpliedEndTags() {\n    while (isImpliedEndTagRequired(this.currentTagName)) {\n      this.pop();\n    }\n  }\n\n  generateImpliedEndTagsThoroughly() {\n    while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {\n      this.pop();\n    }\n  }\n\n  generateImpliedEndTagsWithExclusion(exclusionTagName) {\n    while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {\n      this.pop();\n    }\n  }\n\n}\n\nmodule.exports = OpenElementStack;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/parser/open-element-stack.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/preprocessor.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/preprocessor.js ***!
  \**************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\n__webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n\nconst unicode = __webpack_require__(/*! ../common/unicode */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/common/unicode.js\");\n\nconst ERR = __webpack_require__(/*! ../common/error-codes */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/common/error-codes.js\"); //Aliases\n\n\nconst $ = unicode.CODE_POINTS; //Const\n\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16; //Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\n\nclass Preprocessor {\n  constructor() {\n    this.html = null;\n    this.pos = -1;\n    this.lastGapPos = -1;\n    this.lastCharPos = -1;\n    this.gapStack = [];\n    this.skipNextNewLine = false;\n    this.lastChunkWritten = false;\n    this.endOfChunkHit = false;\n    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n  }\n\n  _err() {// NOTE: err reporting is noop by default. Enabled by mixin.\n  }\n\n  _addGap() {\n    this.gapStack.push(this.lastGapPos);\n    this.lastGapPos = this.pos;\n  }\n\n  _processSurrogate(cp) {\n    //NOTE: try to peek a surrogate pair\n    if (this.pos !== this.lastCharPos) {\n      const nextCp = this.html.charCodeAt(this.pos + 1);\n\n      if (unicode.isSurrogatePair(nextCp)) {\n        //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n        this.pos++; //NOTE: add gap that should be avoided during retreat\n\n        this._addGap();\n\n        return unicode.getSurrogatePairCodePoint(cp, nextCp);\n      }\n    } //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.\n    else if (!this.lastChunkWritten) {\n      this.endOfChunkHit = true;\n      return $.EOF;\n    } //NOTE: isolated surrogate\n\n\n    this._err(ERR.surrogateInInputStream);\n\n    return cp;\n  }\n\n  dropParsedChunk() {\n    if (this.pos > this.bufferWaterline) {\n      this.lastCharPos -= this.pos;\n      this.html = this.html.substring(this.pos);\n      this.pos = 0;\n      this.lastGapPos = -1;\n      this.gapStack = [];\n    }\n  }\n\n  write(chunk, isLastChunk) {\n    if (this.html) {\n      this.html += chunk;\n    } else {\n      this.html = chunk;\n    }\n\n    this.lastCharPos = this.html.length - 1;\n    this.endOfChunkHit = false;\n    this.lastChunkWritten = isLastChunk;\n  }\n\n  insertHtmlAtCurrentPos(chunk) {\n    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);\n    this.lastCharPos = this.html.length - 1;\n    this.endOfChunkHit = false;\n  }\n\n  advance() {\n    this.pos++;\n\n    if (this.pos > this.lastCharPos) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return $.EOF;\n    }\n\n    let cp = this.html.charCodeAt(this.pos); //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n    //must be ignored.\n\n    if (this.skipNextNewLine && cp === $.LINE_FEED) {\n      this.skipNextNewLine = false;\n\n      this._addGap();\n\n      return this.advance();\n    } //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n\n\n    if (cp === $.CARRIAGE_RETURN) {\n      this.skipNextNewLine = true;\n      return $.LINE_FEED;\n    }\n\n    this.skipNextNewLine = false;\n\n    if (unicode.isSurrogate(cp)) {\n      cp = this._processSurrogate(cp);\n    } //OPTIMIZATION: first check if code point is in the common allowed\n    //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n    //before going into detailed performance cost validation.\n\n\n    const isCommonValidRange = cp > 0x1f && cp < 0x7f || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || cp > 0x9f && cp < 0xfdd0;\n\n    if (!isCommonValidRange) {\n      this._checkForProblematicCharacters(cp);\n    }\n\n    return cp;\n  }\n\n  _checkForProblematicCharacters(cp) {\n    if (unicode.isControlCodePoint(cp)) {\n      this._err(ERR.controlCharacterInInputStream);\n    } else if (unicode.isUndefinedCodePoint(cp)) {\n      this._err(ERR.noncharacterInInputStream);\n    }\n  }\n\n  retreat() {\n    if (this.pos === this.lastGapPos) {\n      this.lastGapPos = this.gapStack.pop();\n      this.pos--;\n    }\n\n    this.pos--;\n  }\n\n}\n\nmodule.exports = Preprocessor;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/preprocessor.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/tree-adapters/default.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/tree-adapters/default.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n\n__webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n\nconst {\n  DOCUMENT_MODE\n} = __webpack_require__(/*! ../common/html */ \"./node_modules/hast-util-raw/node_modules/parse5/lib/common/html.js\"); //Node construction\n\n\nexports.createDocument = function () {\n  return {\n    nodeName: '#document',\n    mode: DOCUMENT_MODE.NO_QUIRKS,\n    childNodes: []\n  };\n};\n\nexports.createDocumentFragment = function () {\n  return {\n    nodeName: '#document-fragment',\n    childNodes: []\n  };\n};\n\nexports.createElement = function (tagName, namespaceURI, attrs) {\n  return {\n    nodeName: tagName,\n    tagName: tagName,\n    attrs: attrs,\n    namespaceURI: namespaceURI,\n    childNodes: [],\n    parentNode: null\n  };\n};\n\nexports.createCommentNode = function (data) {\n  return {\n    nodeName: '#comment',\n    data: data,\n    parentNode: null\n  };\n};\n\nconst createTextNode = function (value) {\n  return {\n    nodeName: '#text',\n    value: value,\n    parentNode: null\n  };\n}; //Tree mutation\n\n\nconst appendChild = exports.appendChild = function (parentNode, newNode) {\n  parentNode.childNodes.push(newNode);\n  newNode.parentNode = parentNode;\n};\n\nconst insertBefore = exports.insertBefore = function (parentNode, newNode, referenceNode) {\n  const insertionIdx = parentNode.childNodes.indexOf(referenceNode);\n  parentNode.childNodes.splice(insertionIdx, 0, newNode);\n  newNode.parentNode = parentNode;\n};\n\nexports.setTemplateContent = function (templateElement, contentElement) {\n  templateElement.content = contentElement;\n};\n\nexports.getTemplateContent = function (templateElement) {\n  return templateElement.content;\n};\n\nexports.setDocumentType = function (document, name, publicId, systemId) {\n  let doctypeNode = null;\n\n  for (let i = 0; i < document.childNodes.length; i++) {\n    if (document.childNodes[i].nodeName === '#documentType') {\n      doctypeNode = document.childNodes[i];\n      break;\n    }\n  }\n\n  if (doctypeNode) {\n    doctypeNode.name = name;\n    doctypeNode.publicId = publicId;\n    doctypeNode.systemId = systemId;\n  } else {\n    appendChild(document, {\n      nodeName: '#documentType',\n      name: name,\n      publicId: publicId,\n      systemId: systemId\n    });\n  }\n};\n\nexports.setDocumentMode = function (document, mode) {\n  document.mode = mode;\n};\n\nexports.getDocumentMode = function (document) {\n  return document.mode;\n};\n\nexports.detachNode = function (node) {\n  if (node.parentNode) {\n    const idx = node.parentNode.childNodes.indexOf(node);\n    node.parentNode.childNodes.splice(idx, 1);\n    node.parentNode = null;\n  }\n};\n\nexports.insertText = function (parentNode, text) {\n  if (parentNode.childNodes.length) {\n    const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];\n\n    if (prevNode.nodeName === '#text') {\n      prevNode.value += text;\n      return;\n    }\n  }\n\n  appendChild(parentNode, createTextNode(text));\n};\n\nexports.insertTextBefore = function (parentNode, text, referenceNode) {\n  const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];\n\n  if (prevNode && prevNode.nodeName === '#text') {\n    prevNode.value += text;\n  } else {\n    insertBefore(parentNode, createTextNode(text), referenceNode);\n  }\n};\n\nexports.adoptAttributes = function (recipient, attrs) {\n  const recipientAttrsMap = [];\n\n  for (let i = 0; i < recipient.attrs.length; i++) {\n    recipientAttrsMap.push(recipient.attrs[i].name);\n  }\n\n  for (let j = 0; j < attrs.length; j++) {\n    if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {\n      recipient.attrs.push(attrs[j]);\n    }\n  }\n}; //Tree traversing\n\n\nexports.getFirstChild = function (node) {\n  return node.childNodes[0];\n};\n\nexports.getChildNodes = function (node) {\n  return node.childNodes;\n};\n\nexports.getParentNode = function (node) {\n  return node.parentNode;\n};\n\nexports.getAttrList = function (element) {\n  return element.attrs;\n}; //Node data\n\n\nexports.getTagName = function (element) {\n  return element.tagName;\n};\n\nexports.getNamespaceURI = function (element) {\n  return element.namespaceURI;\n};\n\nexports.getTextNodeContent = function (textNode) {\n  return textNode.value;\n};\n\nexports.getCommentNodeContent = function (commentNode) {\n  return commentNode.data;\n};\n\nexports.getDocumentTypeNodeName = function (doctypeNode) {\n  return doctypeNode.name;\n};\n\nexports.getDocumentTypeNodePublicId = function (doctypeNode) {\n  return doctypeNode.publicId;\n};\n\nexports.getDocumentTypeNodeSystemId = function (doctypeNode) {\n  return doctypeNode.systemId;\n}; //Node types\n\n\nexports.isTextNode = function (node) {\n  return node.nodeName === '#text';\n};\n\nexports.isCommentNode = function (node) {\n  return node.nodeName === '#comment';\n};\n\nexports.isDocumentTypeNode = function (node) {\n  return node.nodeName === '#documentType';\n};\n\nexports.isElementNode = function (node) {\n  return !!node.tagName;\n}; // Source code location\n\n\nexports.setNodeSourceCodeLocation = function (node, location) {\n  node.sourceCodeLocation = location;\n};\n\nexports.getNodeSourceCodeLocation = function (node) {\n  return node.sourceCodeLocation;\n};\n\nexports.updateNodeSourceCodeLocation = function (node, endLocation) {\n  node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);\n};\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/tree-adapters/default.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/utils/merge-options.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/utils/merge-options.js ***!
  \***********************************************************************************/
/***/ (function(module) {

eval("\n\nmodule.exports = function mergeOptions(defaults, options) {\n  options = options || Object.create(null);\n  return [defaults, options].reduce((merged, optObj) => {\n    Object.keys(optObj).forEach(key => {\n      merged[key] = optObj[key];\n    });\n    return merged;\n  }, Object.create(null));\n};\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/utils/merge-options.js?");

/***/ }),

/***/ "./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\n__webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n\nclass Mixin {\n  constructor(host) {\n    const originalMethods = {};\n\n    const overriddenMethods = this._getOverriddenMethods(this, originalMethods);\n\n    for (const key of Object.keys(overriddenMethods)) {\n      if (typeof overriddenMethods[key] === 'function') {\n        originalMethods[key] = host[key];\n        host[key] = overriddenMethods[key];\n      }\n    }\n  }\n\n  _getOverriddenMethods() {\n    throw new Error('Not implemented');\n  }\n\n}\n\nMixin.install = function (host, Ctor, opts) {\n  if (!host.__mixins) {\n    host.__mixins = [];\n  }\n\n  for (let i = 0; i < host.__mixins.length; i++) {\n    if (host.__mixins[i].constructor === Ctor) {\n      return host.__mixins[i];\n    }\n  }\n\n  const mixin = new Ctor(host, opts);\n\n  host.__mixins.push(mixin);\n\n  return mixin;\n};\n\nmodule.exports = Mixin;\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js?");

/***/ }),

/***/ "./node_modules/hast-util-sanitize/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/hast-util-sanitize/lib/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sanitize\": function() { return /* binding */ sanitize; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.regexp.flags.js */ \"./node_modules/core-js/modules/es.regexp.flags.js\");\n/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema.js */ \"./node_modules/hast-util-sanitize/lib/schema.js\");\n\n\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {Content | Root} Node\n *\n * @typedef {Properties[string]} PropertyValue\n *   Possible property values.\n * @typedef {string | number | boolean} PrimitivePropertyValue\n *   Possible primitive HTML attribute values.\n *\n * @typedef {Record<string, Array<string | [string, ...Array<PrimitivePropertyValue | RegExp>]>>} Attributes\n *  Map of tag names to allow lists for each property.\n * @typedef {Record<string, Array<PrimitivePropertyValue | RegExp>>} AttributeClean\n *   Normalized input.\n *\n * @typedef Schema\n *   Sanitization configuration.\n * @property {Attributes | undefined} [attributes]\n *   Map of tag names to allowed properties.\n *\n *   The special `'*'` key defines property names allowed on all elements.\n * @property {Record<string, Record<string, PropertyValue>> | undefined} [required]\n *   Map of tag names to required property names and their default property value.\n * @property {Array<string> | undefined} [tagNames]\n *   List of allowed tag names.\n * @property {Record<string, Array<string>> | undefined} [protocols]\n *   Map of protocols to allow in property values.\n * @property {Record<string, Array<string>> | undefined} [ancestors]\n *   Map of tag names to their required ancestor elements.\n * @property {Array<string> | undefined} [clobber]\n *   List of allowed property names which can clobber.\n * @property {string | undefined} [clobberPrefix]\n *   Prefix to use before potentially clobbering property names.\n * @property {Array<string> | undefined} [strip]\n *   Names of elements to strip from the tree.\n * @property {boolean | undefined} [allowComments]\n *   Whether to allow comments.\n * @property {boolean | undefined} [allowDoctypes]\n *   Whether to allow doctypes.\n *\n * @typedef {(schema: Schema, value: any, node: any, stack: Array<string>) => unknown} Handler\n * @typedef {Record<string, Handler>} NodeDefinition\n * @typedef {((schema: Schema, node: Node) => NodeDefinition | undefined)} NodeDefinitionGetter\n * @typedef {Record<string, NodeDefinition | NodeDefinitionGetter>} NodeSchema\n */\n\nconst own = {}.hasOwnProperty;\n/** @type {NodeSchema} */\n\nconst nodeSchema = {\n  root: {\n    children: all\n  },\n  doctype: handleDoctype,\n  comment: handleComment,\n  element: {\n    tagName: handleTagName,\n    properties: handleProperties,\n    children: all\n  },\n  text: {\n    value: handleValue\n  },\n  '*': {\n    data: allow,\n    position: allow\n  }\n};\n/**\n * Utility to sanitize a tree\n *\n * @param {Node} node\n *   Hast tree to sanitize\n * @param {Schema} [schema]\n *   Schema defining how to sanitize - defaults to Github style sanitation\n */\n\nfunction sanitize(node, schema) {\n  /** @type {Node} */\n  let ctx = {\n    type: 'root',\n    children: []\n  };\n\n  if (node && typeof node === 'object' && node.type) {\n    const replace = one(Object.assign({}, _schema_js__WEBPACK_IMPORTED_MODULE_2__.defaultSchema, schema || {}), node, []);\n\n    if (replace) {\n      if (Array.isArray(replace)) {\n        if (replace.length === 1) {\n          ctx = replace[0];\n        } else {\n          // @ts-expect-error Assume `root` is not a child.\n          ctx.children = replace;\n        }\n      } else {\n        ctx = replace;\n      }\n    }\n  }\n\n  return ctx;\n}\n/**\n * Sanitize `node`.\n *\n * @param {Schema} schema\n * @param {Node} node\n * @param {Array<string>} stack\n * @returns {Node | Array<Node> | undefined}\n */\n\nfunction one(schema, node, stack) {\n  const type = node && node.type;\n  /** @type {Node} */\n  // @ts-expect-error rest of props added later.\n\n  const replacement = {\n    type: node.type\n  };\n  /** @type {boolean | undefined} */\n\n  let replace;\n\n  if (own.call(nodeSchema, type)) {\n    /** @type {NodeDefinition | NodeDefinitionGetter | undefined} */\n    let definition = nodeSchema[type];\n\n    if (typeof definition === 'function') {\n      definition = definition(schema, node);\n    }\n\n    if (definition) {\n      const allowed = Object.assign({}, definition, nodeSchema['*']);\n      /** @type {string} */\n\n      let key;\n      replace = true;\n\n      for (key in allowed) {\n        if (own.call(allowed, key)) {\n          // @ts-expect-error: fine.\n          // type-coverage:ignore-next-line\n          const result = allowed[key](schema, node[key], node, stack); // eslint-disable-next-line max-depth\n\n          if (result === false) {\n            replace = undefined; // Set the non-safe value.\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n\n            replacement[key] = node[key];\n          } else if (result !== undefined && result !== null) {\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = result;\n          }\n        }\n      }\n    }\n  }\n\n  if (replace) {\n    return replacement;\n  }\n\n  return replacement.type === 'element' && schema.strip && !schema.strip.includes(replacement.tagName) ? replacement.children : undefined;\n}\n/**\n * Sanitize `children`.\n *\n * @type {Handler}\n * @param {Array<Node>} children\n * @param {Node} node\n * @returns {Array<Node>}\n */\n\n\nfunction all(schema, children, node, stack) {\n  /** @type {Array<Node>} */\n  const results = [];\n\n  if (Array.isArray(children)) {\n    let index = -1;\n\n    if (node.type === 'element') {\n      stack.push(node.tagName);\n    }\n\n    while (++index < children.length) {\n      const value = one(schema, children[index], stack);\n\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value);\n        } else {\n          results.push(value);\n        }\n      }\n    }\n\n    if (node.type === 'element') {\n      stack.pop();\n    }\n  }\n\n  return results;\n}\n/** @type {NodeDefinitionGetter} */\n\n\nfunction handleDoctype(schema) {\n  return schema.allowDoctypes ? {\n    name: handleDoctypeName\n  } : undefined;\n}\n/** @type {NodeDefinitionGetter} */\n\n\nfunction handleComment(schema) {\n  return schema.allowComments ? {\n    value: handleCommentValue\n  } : undefined;\n}\n/**\n * Sanitize `properties`.\n *\n * @type {Handler}\n * @param {Properties} properties\n * @param {Element} node\n * @returns {Properties}\n */\n\n\nfunction handleProperties(schema, properties, node, stack) {\n  const name = handleTagName(schema, node.tagName, node, stack);\n  /* c8 ignore next */\n\n  const attrs = schema.attributes || {};\n  /* c8 ignore next */\n\n  const reqs = schema.required || {};\n  const props = properties || {};\n  const allowed = Object.assign({}, toPropertyValueMap(attrs['*']), toPropertyValueMap(name && own.call(attrs, name) ? attrs[name] : []));\n  /** @type {Properties} */\n\n  const result = {};\n  /** @type {string} */\n\n  let key;\n\n  for (key in props) {\n    if (own.call(props, key)) {\n      let value = props[key];\n      /** @type {AttributeClean[string]} */\n\n      let definition;\n\n      if (own.call(allowed, key)) {\n        definition = allowed[key];\n      } else if (data(key) && own.call(allowed, 'data*')) {\n        definition = allowed['data*'];\n      } else {\n        continue;\n      }\n\n      value = Array.isArray(value) ? handlePropertyValues(schema, value, key, definition) : handlePropertyValue(schema, value, key, definition);\n\n      if (value !== undefined && value !== null) {\n        result[key] = value;\n      }\n    }\n  }\n\n  if (name && own.call(reqs, name)) {\n    for (key in reqs[name]) {\n      if (!own.call(result, key)) {\n        result[key] = reqs[name][key];\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Always return a valid HTML5 doctype.\n *\n * @type {Handler}\n * @returns {string}\n */\n\n\nfunction handleDoctypeName() {\n  return 'html';\n}\n/**\n * Sanitize `tagName`.\n *\n * @param {Schema} schema\n * @param {string} tagName\n * @param {Node} _\n * @param {Array<string>} stack\n * @returns {string | false}\n */\n\n\nfunction handleTagName(schema, tagName, _, stack) {\n  const name = typeof tagName === 'string' ? tagName : '';\n  let index = -1;\n\n  if (!name || name === '*' || schema.tagNames && !schema.tagNames.includes(name)) {\n    return false;\n  } // Some nodes can break out of their context if they don’t have a certain\n  // ancestor.\n\n\n  if (schema.ancestors && own.call(schema.ancestors, name)) {\n    while (++index < schema.ancestors[name].length) {\n      if (stack.includes(schema.ancestors[name][index])) {\n        return name;\n      }\n    }\n\n    return false;\n  }\n\n  return name;\n}\n/**\n * See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\n\n\nfunction handleCommentValue(_, value) {\n  /** @type {string} */\n  const result = typeof value === 'string' ? value : '';\n  const index = result.indexOf('-->');\n  return index < 0 ? result : result.slice(0, index);\n}\n/**\n * Sanitize `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\n\n\nfunction handleValue(_, value) {\n  return typeof value === 'string' ? value : '';\n}\n/**\n * Allow `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n */\n\n\nfunction allow(_, value) {\n  return value;\n}\n/**\n * Sanitize a property value which is a list.\n *\n * @param {Schema} schema\n * @param {Array<unknown>} values\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {Array<string | number>}\n */\n\n\nfunction handlePropertyValues(schema, values, prop, definition) {\n  let index = -1;\n  /** @type {Array<string | number>} */\n\n  const result = [];\n\n  while (++index < values.length) {\n    const value = handlePropertyValue(schema, values[index], prop, definition);\n\n    if (value !== undefined && value !== null) {\n      // @ts-expect-error Assume no booleans were in arrays.\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n/**\n * Sanitize a property value.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {PropertyValue}\n */\n\n\nfunction handlePropertyValue(schema, value, prop, definition) {\n  if ((typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') && safeProtocol(schema, value, prop) && (definition.length === 0 || definition.some(allowed => allowed && typeof allowed === 'object' && 'flags' in allowed ? allowed.test(String(value)) : allowed === value))) {\n    return schema.clobberPrefix && schema.clobber && schema.clobber.includes(prop) ? schema.clobberPrefix + value : value;\n  }\n}\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @returns {boolean}\n */\n\n\nfunction safeProtocol(schema, value, prop) {\n  const url = String(value);\n  const colon = url.indexOf(':');\n  const questionMark = url.indexOf('?');\n  const numberSign = url.indexOf('#');\n  const slash = url.indexOf('/');\n  const protocols = schema.protocols && own.call(schema.protocols, prop) ? schema.protocols[prop].concat() : [];\n  let index = -1;\n\n  if (protocols.length === 0 || colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {\n    return true;\n  }\n\n  while (++index < protocols.length) {\n    if (colon === protocols[index].length && url.slice(0, protocols[index].length) === protocols[index]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Create a map from a list of props or a list of properties and values.\n *\n * @param {Attributes[string]} values\n * @returns {AttributeClean}\n */\n\n\nfunction toPropertyValueMap(values) {\n  /** @type {AttributeClean} */\n  const result = {};\n  let index = -1;\n\n  while (++index < values.length) {\n    const value = values[index];\n\n    if (Array.isArray(value)) {\n      result[value[0]] = value.slice(1);\n    } else {\n      result[value] = [];\n    }\n  }\n\n  return result;\n}\n/**\n * Check if `prop` is a data property.\n *\n * @param {string} prop\n * @returns {boolean}\n */\n\n\nfunction data(prop) {\n  return prop.length > 4 && prop.slice(0, 4).toLowerCase() === 'data';\n}\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-sanitize/lib/index.js?");

/***/ }),

/***/ "./node_modules/hast-util-sanitize/lib/schema.js":
/*!*******************************************************!*\
  !*** ./node_modules/hast-util-sanitize/lib/schema.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultSchema\": function() { return /* binding */ defaultSchema; }\n/* harmony export */ });\n/** @type {import('./index.js').Schema} */\nconst defaultSchema = {\n  strip: ['script'],\n  clobberPrefix: 'user-content-',\n  clobber: ['name', 'id'],\n  ancestors: {\n    tbody: ['table'],\n    tfoot: ['table'],\n    thead: ['table'],\n    td: ['table'],\n    th: ['table'],\n    tr: ['table']\n  },\n  protocols: {\n    href: ['http', 'https', 'mailto', 'xmpp', 'irc', 'ircs'],\n    cite: ['http', 'https'],\n    src: ['http', 'https'],\n    longDesc: ['http', 'https']\n  },\n  tagNames: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'br', 'b', 'i', 'strong', 'em', 'a', 'pre', 'code', 'img', 'tt', 'div', 'ins', 'del', 'sup', 'sub', 'p', 'ol', 'ul', 'table', 'thead', 'tbody', 'tfoot', 'blockquote', 'dl', 'dt', 'dd', 'kbd', 'q', 'samp', 'var', 'hr', 'ruby', 'rt', 'rp', 'li', 'tr', 'td', 'th', 's', 'strike', 'summary', 'details', 'caption', 'figure', 'figcaption', 'abbr', 'bdo', 'cite', 'dfn', 'mark', 'small', 'span', 'time', 'wbr', 'input'],\n  attributes: {\n    a: ['href'],\n    img: ['src', 'longDesc'],\n    input: [['type', 'checkbox'], ['disabled', true]],\n    li: [['className', 'task-list-item']],\n    div: ['itemScope', 'itemType'],\n    blockquote: ['cite'],\n    del: ['cite'],\n    ins: ['cite'],\n    q: ['cite'],\n    '*': ['abbr', 'accept', 'acceptCharset', 'accessKey', 'action', 'align', 'alt', 'ariaDescribedBy', 'ariaHidden', 'ariaLabel', 'ariaLabelledBy', 'axis', 'border', 'cellPadding', 'cellSpacing', 'char', 'charOff', 'charSet', 'checked', 'clear', 'cols', 'colSpan', 'color', 'compact', 'coords', 'dateTime', 'dir', 'disabled', 'encType', 'htmlFor', 'frame', 'headers', 'height', 'hrefLang', 'hSpace', 'isMap', 'id', 'label', 'lang', 'maxLength', 'media', 'method', 'multiple', 'name', 'noHref', 'noShade', 'noWrap', 'open', 'prompt', 'readOnly', 'rel', 'rev', 'rows', 'rowSpan', 'rules', 'scope', 'selected', 'shape', 'size', 'span', 'start', 'summary', 'tabIndex', 'target', 'title', 'type', 'useMap', 'vAlign', 'value', 'vSpace', 'width', 'itemProp']\n  },\n  required: {\n    input: {\n      type: 'checkbox',\n      disabled: true\n    }\n  }\n};\n\n//# sourceURL=webpack://vadmin-front/./node_modules/hast-util-sanitize/lib/schema.js?");

/***/ })

}]);